{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-e813df45c36319f37b4d9bd46f461db1135b3431",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/multisig/v1/MultiSig.sol": "project/contracts/multisig/v1/MultiSig.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/multisig/v1/MultiSig.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title SimpleMultiSig\n/// @notice Basic multi-signature system (N-of-M)\n/// @notice Allows actions to be proposed and executed only after N approvals from M signers\n/// @notice Useful for secure fund management or settings that require consensus\ncontract MultiSigV1 {\n    address public owner;\n    address[] public signers;\n    mapping(address => bool) public isSigner;\n    uint256 public threshold;\n    \n    uint256 public totalUniqueUsers;\n    mapping(address => bool) public hasInteracted;\n    mapping(address => uint256) public interactionsCount;\n\n    uint256 public proposalCount;\n    \n    struct Proposal {\n        uint256 id;\n        address proposer;\n        address target;\n        uint256 value;\n        bytes data;\n        bool executed;\n        uint256 approvalCount;\n        mapping(address => bool) approvals;\n    }\n    \n    mapping(uint256 => Proposal) public proposals;\n    uint256[] public activeProposalIds;\n\n    error NotOwner();\n    error NotSigner();\n    error InvalidThreshold();\n    error AlreadySigner();\n    error NotASigner();\n    error InvalidProposal();\n    error AlreadyApproved();\n    error NotApproved();\n    error InsufficientApprovals();\n    error AlreadyExecuted();\n    error ExecutionFailed();\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert NotOwner();\n        _;\n    }\n\n    modifier onlySigner() {\n        if (!isSigner[msg.sender]) revert NotSigner();\n        _;\n    }\n\n    constructor(address[] memory _signers, uint256 _threshold) {\n        require(_signers.length > 0, \"Must have at least one signer\");\n        require(_threshold > 0 && _threshold <= _signers.length, \"Invalid threshold\");\n        \n        owner = msg.sender;\n        threshold = _threshold;\n        \n        for (uint256 i = 0; i < _signers.length; i++) {\n            require(_signers[i] != address(0), \"Invalid signer address\");\n            require(!isSigner[_signers[i]], \"Duplicate signer\");\n            \n            isSigner[_signers[i]] = true;\n            signers.push(_signers[i]);\n        }\n        \n        _registerInteraction(msg.sender);\n    }\n\n    function _registerInteraction(address _user) internal {\n        if (!hasInteracted[_user]) {\n            hasInteracted[_user] = true;\n            totalUniqueUsers += 1;\n        }\n        interactionsCount[_user] += 1;\n    }\n\n    event SignerAdded(address indexed signer, uint256 newSignerCount, uint256 threshold);\n    event SignerRemoved(address indexed signer, uint256 newSignerCount, uint256 threshold);\n    event ThresholdChanged(uint256 oldThreshold, uint256 newThreshold);\n    event ProposalCreated(\n        uint256 indexed proposalId,\n        address indexed proposer,\n        address target,\n        uint256 value\n    );\n    event ProposalApproved(uint256 indexed proposalId, address indexed approver, uint256 approvalCount);\n    event ProposalExecuted(uint256 indexed proposalId, address indexed executor);\n    event ProposalCancelled(uint256 indexed proposalId, address indexed canceller);\n\n    /// @notice Adds a new signer to the multi-sig\n    /// @param _signer Address of the new signer\n    function addSigner(address _signer) external onlyOwner {\n        if (_signer == address(0)) revert NotASigner();\n        if (isSigner[_signer]) revert AlreadySigner();\n        \n        isSigner[_signer] = true;\n        signers.push(_signer);\n        \n        _registerInteraction(msg.sender);\n        \n        emit SignerAdded(_signer, signers.length, threshold);\n    }\n\n    /// @notice Removes a signer from the multi-sig\n    /// @dev Requires the threshold to be adjusted first if necessary\n    /// @param _signer Address of the signer to remove\n    function removeSigner(address _signer) external onlyOwner {\n        if (!isSigner[_signer]) revert NotASigner();\n        if (threshold > signers.length - 1) revert InvalidThreshold();\n        \n        isSigner[_signer] = false;\n        \n        for (uint256 i = 0; i < signers.length; i++) {\n            if (signers[i] == _signer) {\n                signers[i] = signers[signers.length - 1];\n                signers.pop();\n                break;\n            }\n        }\n        \n        _registerInteraction(msg.sender);\n        \n        emit SignerRemoved(_signer, signers.length, threshold);\n    }\n\n    /// @notice Adjusts the minimum number of approvals required to execute proposals\n    /// @param _newThreshold New threshold (must be between 1 and number of signers)\n    function setThreshold(uint256 _newThreshold) external onlyOwner {\n        require(_newThreshold > 0 && _newThreshold <= signers.length, \"Invalid threshold\");\n        \n        uint256 oldThreshold = threshold;\n        threshold = _newThreshold;\n        \n        _registerInteraction(msg.sender);\n        \n        emit ThresholdChanged(oldThreshold, _newThreshold);\n    }\n\n    /// @notice Creates a new action proposal\n    /// @param _target Address of the contract/target that will receive the call\n    /// @param _value Value in wei to send (0 for calls without value)\n    /// @param _data Call data (can be empty for simple transfers)\n    /// @return proposalId ID of the created proposal\n    function propose(address _target, uint256 _value, bytes calldata _data) \n        external \n        onlySigner \n        returns (uint256 proposalId) \n    {\n        require(_target != address(0), \"Invalid target\");\n        \n        proposalId = ++proposalCount;\n        \n        Proposal storage p = proposals[proposalId];\n        p.id = proposalId;\n        p.proposer = msg.sender;\n        p.target = _target;\n        p.value = _value;\n        p.data = _data;\n        p.executed = false;\n        p.approvalCount = 1;\n        p.approvals[msg.sender] = true;\n        \n        activeProposalIds.push(proposalId);\n        \n        _registerInteraction(msg.sender);\n        \n        emit ProposalCreated(proposalId, msg.sender, _target, _value);\n        emit ProposalApproved(proposalId, msg.sender, 1);\n    }\n\n    /// @notice Approves an existing proposal\n    /// @param _proposalId ID of the proposal to approve\n    function approve(uint256 _proposalId) external onlySigner {\n        Proposal storage p = proposals[_proposalId];\n        \n        if (p.id == 0) revert InvalidProposal();\n        if (p.executed) revert AlreadyExecuted();\n        if (p.approvals[msg.sender]) revert AlreadyApproved();\n        \n        p.approvals[msg.sender] = true;\n        p.approvalCount += 1;\n        \n        _registerInteraction(msg.sender);\n        \n        emit ProposalApproved(_proposalId, msg.sender, p.approvalCount);\n    }\n\n    /// @notice Executes a proposal that has reached the approval threshold\n    /// @dev Can be called by any address after reaching the required approvals\n    /// @param _proposalId ID of the proposal to execute\n    function execute(uint256 _proposalId) external {\n        Proposal storage p = proposals[_proposalId];\n        \n        if (p.id == 0) revert InvalidProposal();\n        if (p.executed) revert AlreadyExecuted();\n        if (p.approvalCount < threshold) revert InsufficientApprovals();\n        \n        p.executed = true;\n        \n        _removeFromActiveProposals(_proposalId);\n        \n        (bool success, ) = p.target.call{value: p.value}(p.data);\n        if (!success) revert ExecutionFailed();\n        \n        _registerInteraction(msg.sender);\n        \n        emit ProposalExecuted(_proposalId, msg.sender);\n    }\n\n    /// @notice Cancels a proposal (only by the proposer or owner)\n    /// @param _proposalId ID of the proposal to cancel\n    function cancel(uint256 _proposalId) external {\n        Proposal storage p = proposals[_proposalId];\n        \n        if (p.id == 0) revert InvalidProposal();\n        if (p.executed) revert AlreadyExecuted();\n        \n        require(\n            msg.sender == p.proposer || msg.sender == owner,\n            \"Not authorized to cancel\"\n        );\n        \n        p.executed = true;\n        _removeFromActiveProposals(_proposalId);\n        \n        _registerInteraction(msg.sender);\n        \n        emit ProposalCancelled(_proposalId, msg.sender);\n    }\n\n    function _removeFromActiveProposals(uint256 _proposalId) internal {\n        for (uint256 i = 0; i < activeProposalIds.length; i++) {\n            if (activeProposalIds[i] == _proposalId) {\n                activeProposalIds[i] = activeProposalIds[activeProposalIds.length - 1];\n                activeProposalIds.pop();\n                break;\n            }\n        }\n    }\n\n    /// @notice Returns detailed information about a proposal\n    /// @param _proposalId ID of the proposal\n    /// @return id ID of the proposal\n    /// @return proposer Address of the proposer\n    /// @return target Target address of the proposal\n    /// @return value Value in wei of the proposal\n    /// @return executed Whether it has been executed\n    /// @return approvalCount Number of approvals\n    /// @return canExecute Whether it can be executed now\n    function getProposal(uint256 _proposalId)\n        external\n        view\n        returns (\n            uint256 id,\n            address proposer,\n            address target,\n            uint256 value,\n            bool executed,\n            uint256 approvalCount,\n            bool canExecute\n        )\n    {\n        Proposal storage p = proposals[_proposalId];\n        return (\n            p.id,\n            p.proposer,\n            p.target,\n            p.value,\n            p.executed,\n            p.approvalCount,\n            !p.executed && p.approvalCount >= threshold\n        );\n    }\n\n    /// @notice Checks if a signer has approved a specific proposal\n    /// @param _proposalId ID of the proposal\n    /// @param _signer Address of the signer\n    /// @return true if approved, false otherwise\n    function hasApproved(uint256 _proposalId, address _signer)\n        external\n        view\n        returns (bool)\n    {\n        return proposals[_proposalId].approvals[_signer];\n    }\n\n    /// @notice Returns array with all active signers\n    /// @return Array of signer addresses\n    function getSigners() external view returns (address[] memory) {\n        return signers;\n    }\n\n    /// @notice Returns IDs of all active (non-executed) proposals\n    /// @return Array with IDs of active proposals\n    function getActiveProposals() external view returns (uint256[] memory) {\n        return activeProposalIds;\n    }\n\n    /// @notice Returns the total number of signers\n    /// @return Number of signers\n    function getSignerCount() external view returns (uint256) {\n        return signers.length;\n    }\n\n    /// @notice Returns how many times the caller has interacted with the contract\n    /// @return Number of interactions\n    function myInteractions() external view returns (uint256) {\n        return interactionsCount[msg.sender];\n    }\n\n    receive() external payable {}\n}"
      }
    }
  }
}