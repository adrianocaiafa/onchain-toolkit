{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-8ab152166dfbb90b32d6658d2e2c5bf776118772",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/multisig/v2/MultiSig.sol": "project/contracts/multisig/v2/MultiSig.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/multisig/v2/MultiSig.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title MultiSigV2\n/// @notice Enhanced multi-signature system (N-of-M) with timelock, expiration, and improved security\n/// @notice Allows actions to be proposed and executed only after N approvals from M signers\n/// @notice Features: timelock delays, proposal expiration, delegatecall protection, and governance via proposals\ncontract MultiSigV2 {\n    address[] public signers;\n    mapping(address => bool) public isSigner;\n    uint256 public threshold;\n    \n    uint256 public totalUniqueUsers;\n    mapping(address => bool) public hasInteracted;\n    mapping(address => uint256) public interactionsCount;\n\n    uint256 public proposalCount;\n    \n    // Default timelock: 1 hour for normal proposals, 7 days for critical operations\n    uint256 public constant DEFAULT_TIMELOCK = 1 hours;\n    uint256 public constant CRITICAL_TIMELOCK = 7 days;\n    uint256 public constant DEFAULT_EXPIRATION = 30 days;\n    \n    struct Proposal {\n        uint256 id;\n        address proposer;\n        address target;\n        uint256 value;\n        bytes data;\n        bool executed;\n        uint256 approvalCount;\n        uint256 timelock;        // Minimum delay before execution (in seconds)\n        uint256 createdAt;       // Timestamp when proposal was created\n        uint256 expiresAt;       // Timestamp when proposal expires\n        mapping(address => bool) approvals;\n    }\n    \n    mapping(uint256 => Proposal) public proposals;\n    uint256[] public activeProposalIds;\n\n    error NotSigner();\n    error InvalidThreshold();\n    error AlreadySigner();\n    error NotASigner();\n    error InvalidProposal();\n    error AlreadyApproved();\n    error NotApproved();\n    error InsufficientApprovals();\n    error AlreadyExecuted();\n    error ExecutionFailed();\n    error TimelockNotMet();\n    error ProposalExpired();\n    error NotProposer();\n    error DelegatecallNotAllowed();\n\n    modifier onlySigner() {\n        if (!isSigner[msg.sender]) revert NotSigner();\n        _;\n    }\n\n    constructor(address[] memory _signers, uint256 _threshold) {\n        require(_signers.length > 0, \"Must have at least one signer\");\n        require(_threshold > 0 && _threshold <= _signers.length, \"Invalid threshold\");\n        \n        threshold = _threshold;\n        \n        for (uint256 i = 0; i < _signers.length; i++) {\n            require(_signers[i] != address(0), \"Invalid signer address\");\n            require(!isSigner[_signers[i]], \"Duplicate signer\");\n            \n            isSigner[_signers[i]] = true;\n            signers.push(_signers[i]);\n        }\n        \n        _registerInteraction(msg.sender);\n    }\n\n    function _registerInteraction(address _user) internal {\n        if (!hasInteracted[_user]) {\n            hasInteracted[_user] = true;\n            totalUniqueUsers += 1;\n        }\n        interactionsCount[_user] += 1;\n    }\n\n    event SignerAdded(address indexed signer, uint256 newSignerCount, uint256 threshold);\n    event SignerRemoved(address indexed signer, uint256 newSignerCount, uint256 threshold);\n    event ThresholdChanged(uint256 oldThreshold, uint256 newThreshold);\n    event ProposalCreated(\n        uint256 indexed proposalId,\n        address indexed proposer,\n        address target,\n        uint256 value,\n        uint256 timelock,\n        uint256 expiresAt\n    );\n    event ProposalApproved(uint256 indexed proposalId, address indexed approver, uint256 approvalCount);\n    event ProposalExecuted(uint256 indexed proposalId, address indexed executor);\n    event ProposalCancelled(uint256 indexed proposalId, address indexed canceller);\n\n    /// @notice Creates a new action proposal\n    /// @param _target Address of the contract/target that will receive the call\n    /// @param _value Value in wei to send (0 for calls without value)\n    /// @param _data Call data (can be empty for simple transfers)\n    /// @param _timelock Custom timelock in seconds (0 to use default)\n    /// @param _expiration Custom expiration in seconds from now (0 to use default)\n    /// @return proposalId ID of the created proposal\n    function propose(\n        address _target,\n        uint256 _value,\n        bytes calldata _data,\n        uint256 _timelock,\n        uint256 _expiration\n    ) external onlySigner returns (uint256 proposalId) {\n        require(_target != address(0), \"Invalid target\");\n        \n        proposalId = ++proposalCount;\n        uint256 currentTime = block.timestamp;\n        \n        // Use default timelock if not specified\n        uint256 timelock = _timelock == 0 ? DEFAULT_TIMELOCK : _timelock;\n        // Use default expiration if not specified\n        uint256 expiration = _expiration == 0 ? DEFAULT_EXPIRATION : _expiration;\n        \n        Proposal storage p = proposals[proposalId];\n        p.id = proposalId;\n        p.proposer = msg.sender;\n        p.target = _target;\n        p.value = _value;\n        p.data = _data;\n        p.executed = false;\n        p.approvalCount = 1;\n        p.timelock = timelock;\n        p.createdAt = currentTime;\n        p.expiresAt = currentTime + expiration;\n        p.approvals[msg.sender] = true;\n        \n        activeProposalIds.push(proposalId);\n        \n        _registerInteraction(msg.sender);\n        \n        emit ProposalCreated(proposalId, msg.sender, _target, _value, timelock, p.expiresAt);\n        emit ProposalApproved(proposalId, msg.sender, 1);\n    }\n\n    /// @notice Approves an existing proposal\n    /// @param _proposalId ID of the proposal to approve\n    function approve(uint256 _proposalId) external onlySigner {\n        Proposal storage p = proposals[_proposalId];\n        \n        if (p.id == 0) revert InvalidProposal();\n        if (p.executed) revert AlreadyExecuted();\n        if (block.timestamp > p.expiresAt) revert ProposalExpired();\n        if (p.approvals[msg.sender]) revert AlreadyApproved();\n        \n        p.approvals[msg.sender] = true;\n        p.approvalCount += 1;\n        \n        _registerInteraction(msg.sender);\n        \n        emit ProposalApproved(_proposalId, msg.sender, p.approvalCount);\n    }\n\n    /// @notice Executes a proposal that has reached the approval threshold\n    /// @dev Can be called by any address after reaching required approvals and timelock\n    /// @param _proposalId ID of the proposal to execute\n    function execute(uint256 _proposalId) external {\n        Proposal storage p = proposals[_proposalId];\n        \n        if (p.id == 0) revert InvalidProposal();\n        if (p.executed) revert AlreadyExecuted();\n        if (block.timestamp > p.expiresAt) revert ProposalExpired();\n        if (p.approvalCount < threshold) revert InsufficientApprovals();\n        if (block.timestamp < p.createdAt + p.timelock) revert TimelockNotMet();\n        \n        p.executed = true;\n        \n        _removeFromActiveProposals(_proposalId);\n        \n        // Protection against delegatecall - block dangerous call patterns\n        _validateCallSafety(p.data);\n        \n        // Convert stored bytes to calldata for execution\n        bytes memory callData = p.data;\n        (bool success, ) = p.target.call{value: p.value}(callData);\n        if (!success) revert ExecutionFailed();\n        \n        _registerInteraction(msg.sender);\n        \n        emit ProposalExecuted(_proposalId, msg.sender);\n    }\n\n    /// @notice Cancels a proposal (only by the proposer)\n    /// @param _proposalId ID of the proposal to cancel\n    function cancel(uint256 _proposalId) external {\n        Proposal storage p = proposals[_proposalId];\n        \n        if (p.id == 0) revert InvalidProposal();\n        if (p.executed) revert AlreadyExecuted();\n        if (msg.sender != p.proposer) revert NotProposer();\n        \n        p.executed = true;\n        _removeFromActiveProposals(_proposalId);\n        \n        _registerInteraction(msg.sender);\n        \n        emit ProposalCancelled(_proposalId, msg.sender);\n    }\n\n    /// @notice Validates call data to prevent delegatecall and other dangerous operations\n    /// @param _data The call data to validate\n    function _validateCallSafety(bytes memory _data) internal pure {\n        if (_data.length < 4) return; // Empty or too short, safe\n        \n        bytes4 selector = bytes4(_data);\n        \n        // Block delegatecall (0xb61d27f6) and callcode (0xa9059cbb is transfer, but we check for delegatecall)\n        // Common delegatecall selectors:\n        // - delegatecall: 0xb61d27f6 (delegatecall(address,bytes))\n        // - callcode: 0x4f51f97b (deprecated but still dangerous)\n        // - selfdestruct: 0x00f55d9d (selfdestruct(address))\n        if (\n            selector == 0xb61d27f6 || // delegatecall\n            selector == 0x4f51f97b || // callcode (deprecated)\n            selector == 0x00f55d9d    // selfdestruct\n        ) {\n            revert DelegatecallNotAllowed();\n        }\n        \n        // Additional check: if data contains delegatecall opcode (0xf4) in first bytes\n        // This catches attempts to use inline assembly or low-level calls\n        for (uint256 i = 0; i < _data.length && i < 100; i++) {\n            if (uint8(_data[i]) == 0xf4) { // DELEGATECALL opcode\n                revert DelegatecallNotAllowed();\n            }\n        }\n    }\n\n    /// @notice Internal helper to create proposals with bytes memory data\n    function _createProposal(\n        address _target,\n        uint256 _value,\n        bytes memory _data,\n        uint256 _timelock,\n        uint256 _expiration\n    ) internal returns (uint256) {\n        // Convert bytes memory to calldata by creating a new proposal structure\n        proposalCount++;\n        uint256 proposalId = proposalCount;\n        uint256 currentTime = block.timestamp;\n        \n        uint256 timelock = _timelock == 0 ? DEFAULT_TIMELOCK : _timelock;\n        uint256 expiration = _expiration == 0 ? DEFAULT_EXPIRATION : _expiration;\n        \n        Proposal storage p = proposals[proposalId];\n        p.id = proposalId;\n        p.proposer = msg.sender;\n        p.target = _target;\n        p.value = _value;\n        p.data = _data;\n        p.executed = false;\n        p.approvalCount = 1;\n        p.timelock = timelock;\n        p.createdAt = currentTime;\n        p.expiresAt = currentTime + expiration;\n        p.approvals[msg.sender] = true;\n        \n        activeProposalIds.push(proposalId);\n        \n        _registerInteraction(msg.sender);\n        \n        emit ProposalCreated(proposalId, msg.sender, _target, _value, timelock, p.expiresAt);\n        emit ProposalApproved(proposalId, msg.sender, 1);\n        \n        return proposalId;\n    }\n\n    /// @notice Creates a proposal to add a new signer (governance via proposal)\n    /// @param _signer Address of the new signer to add\n    /// @return proposalId ID of the created proposal\n    function proposeAddSigner(address _signer) external onlySigner returns (uint256 proposalId) {\n        if (_signer == address(0)) revert NotASigner();\n        if (isSigner[_signer]) revert AlreadySigner();\n        \n        // Encode the addSigner call\n        bytes memory data = abi.encodeWithSignature(\"_executeAddSigner(address)\", _signer);\n        \n        // Use critical timelock for administrative operations\n        proposalId = _createProposal(address(this), 0, data, CRITICAL_TIMELOCK, DEFAULT_EXPIRATION);\n    }\n\n    /// @notice Creates a proposal to remove a signer (governance via proposal)\n    /// @param _signer Address of the signer to remove\n    /// @return proposalId ID of the created proposal\n    function proposeRemoveSigner(address _signer) external onlySigner returns (uint256 proposalId) {\n        if (!isSigner[_signer]) revert NotASigner();\n        if (threshold > signers.length - 1) revert InvalidThreshold();\n        \n        // Encode the removeSigner call\n        bytes memory data = abi.encodeWithSignature(\"_executeRemoveSigner(address)\", _signer);\n        \n        // Use critical timelock for administrative operations\n        proposalId = _createProposal(address(this), 0, data, CRITICAL_TIMELOCK, DEFAULT_EXPIRATION);\n    }\n\n    /// @notice Creates a proposal to change the threshold (governance via proposal)\n    /// @param _newThreshold New threshold value\n    /// @return proposalId ID of the created proposal\n    function proposeSetThreshold(uint256 _newThreshold) external onlySigner returns (uint256 proposalId) {\n        require(_newThreshold > 0 && _newThreshold <= signers.length, \"Invalid threshold\");\n        \n        // Encode the setThreshold call\n        bytes memory data = abi.encodeWithSignature(\"_executeSetThreshold(uint256)\", _newThreshold);\n        \n        // Use critical timelock for administrative operations\n        proposalId = _createProposal(address(this), 0, data, CRITICAL_TIMELOCK, DEFAULT_EXPIRATION);\n    }\n\n    /// @notice Internal function to execute addSigner (called via proposal execution)\n    /// @param _signer Address of the signer to add\n    function _executeAddSigner(address _signer) external {\n        require(msg.sender == address(this), \"Only self-call allowed\");\n        if (_signer == address(0)) revert NotASigner();\n        if (isSigner[_signer]) revert AlreadySigner();\n        \n        isSigner[_signer] = true;\n        signers.push(_signer);\n        \n        emit SignerAdded(_signer, signers.length, threshold);\n    }\n\n    /// @notice Internal function to execute removeSigner (called via proposal execution)\n    /// @param _signer Address of the signer to remove\n    function _executeRemoveSigner(address _signer) external {\n        require(msg.sender == address(this), \"Only self-call allowed\");\n        if (!isSigner[_signer]) revert NotASigner();\n        if (threshold > signers.length - 1) revert InvalidThreshold();\n        \n        isSigner[_signer] = false;\n        \n        for (uint256 i = 0; i < signers.length; i++) {\n            if (signers[i] == _signer) {\n                signers[i] = signers[signers.length - 1];\n                signers.pop();\n                break;\n            }\n        }\n        \n        emit SignerRemoved(_signer, signers.length, threshold);\n    }\n\n    /// @notice Internal function to execute setThreshold (called via proposal execution)\n    /// @param _newThreshold New threshold value\n    function _executeSetThreshold(uint256 _newThreshold) external {\n        require(msg.sender == address(this), \"Only self-call allowed\");\n        require(_newThreshold > 0 && _newThreshold <= signers.length, \"Invalid threshold\");\n        \n        uint256 oldThreshold = threshold;\n        threshold = _newThreshold;\n        \n        emit ThresholdChanged(oldThreshold, _newThreshold);\n    }\n\n    /// @notice Returns detailed information about a proposal\n    /// @param _proposalId ID of the proposal\n    /// @return id ID of the proposal\n    /// @return proposer Address of the proposer\n    /// @return target Target address of the proposal\n    /// @return value Value in wei of the proposal\n    /// @return executed Whether it has been executed\n    /// @return approvalCount Number of approvals\n    /// @return timelock Timelock delay in seconds\n    /// @return createdAt Timestamp when proposal was created\n    /// @return expiresAt Timestamp when proposal expires\n    /// @return executable Whether it can be executed now (checks approvals, timelock, expiration)\n    function getProposal(uint256 _proposalId)\n        external\n        view\n        returns (\n            uint256 id,\n            address proposer,\n            address target,\n            uint256 value,\n            bool executed,\n            uint256 approvalCount,\n            uint256 timelock,\n            uint256 createdAt,\n            uint256 expiresAt,\n            bool executable\n        )\n    {\n        Proposal storage p = proposals[_proposalId];\n        uint256 currentTime = block.timestamp;\n        bool timelockMet = currentTime >= p.createdAt + p.timelock;\n        bool notExpired = currentTime <= p.expiresAt;\n        bool hasApprovals = p.approvalCount >= threshold;\n        \n        return (\n            p.id,\n            p.proposer,\n            p.target,\n            p.value,\n            p.executed,\n            p.approvalCount,\n            p.timelock,\n            p.createdAt,\n            p.expiresAt,\n            !p.executed && hasApprovals && timelockMet && notExpired\n        );\n    }\n\n    /// @notice Checks if a signer has approved a specific proposal\n    /// @param _proposalId ID of the proposal\n    /// @param _signer Address of the signer\n    /// @return true if approved, false otherwise\n    function hasApproved(uint256 _proposalId, address _signer)\n        external\n        view\n        returns (bool)\n    {\n        return proposals[_proposalId].approvals[_signer];\n    }\n\n    /// @notice Returns array with all active signers\n    /// @return Array of signer addresses\n    function getSigners() external view returns (address[] memory) {\n        return signers;\n    }\n\n    /// @notice Returns IDs of all active (non-executed and non-expired) proposals\n    /// @return Array with IDs of active proposals\n    function getActiveProposals() external view returns (uint256[] memory) {\n        uint256[] memory active = new uint256[](activeProposalIds.length);\n        uint256 count = 0;\n        uint256 currentTime = block.timestamp;\n        \n        for (uint256 i = 0; i < activeProposalIds.length; i++) {\n            Proposal storage p = proposals[activeProposalIds[i]];\n            if (!p.executed && currentTime <= p.expiresAt) {\n                active[count] = activeProposalIds[i];\n                count++;\n            }\n        }\n        \n        // Resize array to actual count\n        uint256[] memory result = new uint256[](count);\n        for (uint256 i = 0; i < count; i++) {\n            result[i] = active[i];\n        }\n        \n        return result;\n    }\n\n    /// @notice Returns the total number of signers\n    /// @return Number of signers\n    function getSignerCount() external view returns (uint256) {\n        return signers.length;\n    }\n\n    /// @notice Returns how many times the caller has interacted with the contract\n    /// @return Number of interactions\n    function myInteractions() external view returns (uint256) {\n        return interactionsCount[msg.sender];\n    }\n\n    /// @notice Checks if a proposal can be executed (all conditions met)\n    /// @param _proposalId ID of the proposal\n    /// @return true if proposal can be executed, false otherwise\n    function canExecute(uint256 _proposalId) external view returns (bool) {\n        Proposal storage p = proposals[_proposalId];\n        if (p.id == 0 || p.executed) return false;\n        \n        uint256 currentTime = block.timestamp;\n        return p.approvalCount >= threshold \n            && currentTime >= p.createdAt + p.timelock\n            && currentTime <= p.expiresAt;\n    }\n\n    function _removeFromActiveProposals(uint256 _proposalId) internal {\n        for (uint256 i = 0; i < activeProposalIds.length; i++) {\n            if (activeProposalIds[i] == _proposalId) {\n                activeProposalIds[i] = activeProposalIds[activeProposalIds.length - 1];\n                activeProposalIds.pop();\n                break;\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
      }
    }
  }
}